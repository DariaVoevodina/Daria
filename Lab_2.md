## Cодержание

1. [Отчет по лабораторной работе № N](#отчет-по-лабораторной-работе--n)
2. [Критерии оценивания](#критерии-оценивания)

## Отчет по лабораторной работе № 2

#### № группы: ` ПМ-2401`

#### Выполнил: `Воеводина Дарья Андреевна`

#### Вариант: `5`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Математическая модель](#25-математическая-модель)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

- Условия задачи

>Напишите программу на Java, которая выполняет следующие действия
с двумерным массивом целых чисел:
>1. Считывает с консоли размеры массива N и M, затем элементы
   массива размером N × M. Затем вводит число K.
>2. Сортирует элементы каждой строки по возрастанию остатков от
   деления на K. Если остатки равны, сортирует элементы по убыванию. Если элементы равны, учитывает количество их вхождений в
   строке.
>3. Находит произведение максимальных элементов каждой строки, а
   также их индексы в строках.
>4. Выводит элементы массива в транспонированном виде.
>5. Удаляет из массива все элементы, которые являются кратными
   числу K, выводит получившийся массив массивов, а также количество удалённых элементов.


- Для выполнения задач необходимо выполнить 5 подзадач
1. Ввести массив
2. Отсортировать массив, по заданному критерию
3. Найти максимальные элементы в строках, их произведение и индексы
4. Вывести отсортированный массив в транспонированном виде
5. Вывести массив без определенных элементов
### 2. Входные и выходные данные

#### Данные на вход

На вход программа получает три числа - размеры массива(n,m), а также значение числа k, которое необходимо для сортировки массива по условию
Так как размеры масива не могут быть отрицательными и равными нулю, то минимальное значение n и m - 1
Максимальное значение не указана - возьмём 1000
Число k может принимать любые значения, кроме 0, так как мы будем искать остаток от деления на это число во время сортировки. Возьмём произвольные значения от -1000 до 1000, исключая 0.
Также вводиться двумерный массив, элементы которого могут принимать любые значения. Возьмём произвольные от -1000 до 1000.

|              | Тип              | min значение | max значение |
|--------------|------------------|--------------|--------------|
| n (Число 1)  | Целое число      | 1            | 1000         |
| m (Число 2)  | Целое число      | 1            | 1000         |
| a (Массив 1) | Двумерный массив | -1000        | 1000         |
| k (Число 2)  | Целое число      | -1000        | 1000         |


#### Данные на выход

На выходе мы получаем два массива, и количесиво удаленных элементов из одного из них

|                                          | Тип              | min значение | max значение |
|------------------------------------------|------------------|--------------|--------------|
| Массив 1 (в транспонированном виде)      | Двумерный массив | -1000        | 1000         |
| Массив 2 (с удаленными элементами        | Двумерный массив | -1000        | 1000         |
| Число  1 (количество удаленных элементов | Целое число      | 0            | 1000         |

### 2,5 Математическая модель
Транспонированная матрица — это матрица, полученная из исходной матрицы заменой строк на столбцы. 

### 3. Выбор структуры данных

 Числа m,n,k - тип int (тк m,n - размеры массива,а k делитель )
Массив а - целочисленный массив по условию

|            | название переменной | Тип (в Java) | 
|------------|---------------------|--------------|
| (Число 1)  | n                   | `int`        |
| (Число 2)  | m`                  | `int`        | 
| (Массив 1) | a                   | `int[][]`    |
| (Число 3)  | k                   | `int`        |

На выходе, мы получаем два целочисленных массива, так как это измененный исходный массив
Число count - количество, удаленных элементов, которое может быть только положительным

|            | название переменной | Тип (в Java) | 
|------------|---------------------|--------------|
| (Массив 1) | transp_a            | `int[][]`    |
| (Массив 2) | а                   | `int[][] `   | 
| (Число 1)  | count               | `int`        |

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. Ввод с клавиатуры размеров массива n и m. Затем ввод самого массива, при помощи двух циклов for. Ввод числа k, необходимого для сортировки массива
2. Сортировка элементов каждой строки массива "пузырьком", по возрастанию остатка от деления на k, если остатки от деления на k  равны, элементы строки сортируются также "пузырьком" в порядке убывания
3. С помощью цикла for находим в каждой строке двумерного массива максимальный элемент, запоминаем его. Далее снова циклом for идём по элементам каждой строки, и если всречаем элемент равный максимуму, то выводим его индекс, так программа запоминает индексы максимумов каждлй строки. Вне цикла по элементам строк массива, считаем произведение максимумов
4. Чтобы вывести массив в транспонированном виде, создаем новый пустой массив с размерами, отличными от исходных. Теперь количество строк - количество столбцов, количество столбцов - количество строк. При помощи цикла for заполняем массив элементами, исходного массива, но с другими индексами. Выводим получившийся массив, с помощью двух циклов for.
5. Для подсчёта удаленных элементов заводим счётчик и обнуляем его. Для удаления необходимых элементов из массива, идем по элементам каждой строки, заводим два счётчика, один текущий, другой для получения новой длины строки, если элемент нас устраивает увеличиваем второй счётчик на 1.Если нет, увеличиваем счётчик для количества удалённых элементов на 1. Выводим при помощи двух for получившийся массив. Один из for будет до новой длины.
 
### 5. Программа

Полный текст программы с комментариями на русском языке

Нужно вставить код прямо в отчет в блок:

```markdown
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        //1. Считываем размеры массива с консоли, его элементы, переменную  k
        //вводим размеры массива n на m
        int n = in.nextInt();
        int m = in.nextInt();
        int[][] a = new int[n][m];
        //вводим элементы массива
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[i].length; j++)
                a[i][j] = in.nextInt();
        //вводим число k
        int k = in.nextInt();
        //2. Сортировка "пузырьком" элементов строк массива по возрастанию остатков от деления элементов на k
        int temp;//создаем локальную переменную, которая понадобиться для запоминания текущего значения элемнта при сортировки
        int temp1;//создаем ещё одну локальную переменную, которая понадобиться для сортировки в случае равенства остатков
        for (int i = 0; i < a.length; i++) { //циклом for идем по строкам двумерного массива
            for (int z = 1; z < m; z++) { //Заводим цикл for для z,необходимый для проверки без предыдущего найденного элемента, дающего наибольший остаток от деления на k
                for (int j = 0; j < m - z; j++) {//Заводим цикл for для j,необходимый для проверки без предыдущего найденного элем ента, дающего наибольший остаток от деления на k
                    if (a[i][j] % k > a[i][j + 1] % k) {//Проверка условия "Если остаток от деления текущего элемента на k больше остатка от деления следующего элемента на k
                        temp = a[i][j];//присваиваем локальной переменной значение текущего элемента массива
                        a[i][j] = a[i][j + 1];//присваваем элементу a[i][j] значение элемента a[i][j+1]
                        a[i][j + 1] = temp;//присваиваем элементу a[i][j+1] значение temp
                    }
                    else {
                        if(a[i][j]%k==a[i][j+1]%k&&a[i][j]<a[i][j+1]){//в случае если остатки от деления элементов на k равны, то сортируем их пузырком по убыванию
                            temp1=a[i][j];//присваиваем локальной переменной значение текущего элемента
                            a[i][j]=a[i][j+1];//присваваем элементу a[i][j] значение элемента a[i][j+1]
                            a[i][j+1]=temp1;//присваиваем элементу a[i][j+1] значение temp
                        }
                    }
                }
            }
        }
        //Это была проверка, на правильность работы программы
        //for (int i = 0; i < a.length; i++) {
            //for (int j = 0; j < a[i].length; j++) {
                //out.print(a[i][j] + " ");
            //}
            //out.println();
        //}
        //3. Находим максимум в каждой строке, произведение максмумов и запоминаем их индексы
        int product=1;//Присваиваем, переменной, в которой будем считать произведение 1 (нейтральный элемент по умножению)
        int max_str;//Инициализируем переменную, которая будет запоминать максимум в каждой строке
        int index_max;//Инициализируем переменную, которая будет запоминать индексы максимумов
        for(int i=0;i<a.length;i++) {//Идем по строкам двумерного массива циклом for
            max_str = Integer.MIN_VALUE;//Для каждой строки обновляем значение максимума, присваиваем ему маленкое значение
            for (int j = 0; j < m; j++) {//Идем по элементам каждой строке массива циклом for
                if (a[i][j] > max_str) {//Сравниваем каждый элемент со значением максимума
                    max_str = a[i][j];//Если он оказался больше текущего максимума, присваиваем максимуму значение элемента
                }
            }
            for (int z=0;z<m;z++){//Снова идем по элементам каждой строки
                index_max=0;
                if (a[i][z]==max_str){//Если элемент, оказался равен максимум, то присваиваем переменной, запоминающей индекс, значение индекса максимума
                    index_max=z;
                    //out.print(z+" ");//Это была проверка на корректность работы программы
                }
            }
            product *= max_str;//Считаем произведение макксимумов
        }
        //out.println(product);//Это была проверка на корректность работы программы
        //4. Создание нового массива (прежний массив в транспонированном виде) и его вывод
        int str=a.length;//Присваиваем переменной str количество строк массива
        int stl=a[0].length;//Присваеваем переменной stl количество столбцов массива
        int [][] transp_a=new int[stl][str];//Создаем новый массив с иными размерами(количество строк - количество столбцов предыдущего массива, количество столбцов - количество строк в предыдущем массиве)
        for (int i=0; i<str;i++){//Идем по строкам предыдущего массива циклом for
            for (int j=0;j<stl;j++){//Идем по элементам каждой строки предыдущего массива
                transp_a[j][i]=a[i][j];//Заполняем новый массив элементами предыдущего
            }
        }
        //Выводим новый получившийся массив на экран(это будет старый массив в транспонированном виде
        for (int i=0;i<stl;i++){
            for (int j=0;j<str;j++){
                out.print(transp_a[i][j]+" ");
            }
            out.println();
        }
        //5. Если элемент делится на k без остатка, то удаляем его из массива
        int count=0;//Обнуляем переменную переменную, которая будетсчитать количество удаленных элементов
        int len=0;//Обнуляем пременную для новой длины строк
        for(int i=0;i<a.length;i++){//Циклом for идем по строкам двумерного массива
            for(int z=0,j=0;j<a[i].length;j++){//Циклом for идем по элементам строки текущий счётчик увеличиваем на 1, также обнуляем счётчик для новой длины строк
                if (a[i][j]%k!=0){//Проверяем условие, если элемент нас устраивает
                    a[i][z]=a[i][j];//То присваиваем элемент
                    z++;//Счётчик новой длины увеличиваем на 1
                }
                else{
                    count++;//Если условие не выполняется, то увеличиваем счётчик для удаленных переменных на 1
                }
                len=z;//Переменной новой длины присваиваем значение z
            }
        }
        //Выводим получившийся массив
        for(int i=0;i<a.length;i++) {
            for (int j = 0; j < len; j++) {
                out.print(a[i][j] + " ");
            }
            out.println();
        }
         out.println(count);//Выводим количество удаленных элементов
    }
}

```

Это будет выглядеть следующим образом:

```java
class Main{
    // Что-то далее
}
```

### 6. Анализ правильности решения

Привести тесты и анализ работы программы для этих тестов.
Очень неплохо было бы обосновать выбор тестов.

1. Тест на правильность сортировки, подсчёта произведения максимума и запоминания индексов(это делается по отсортированому массиву)

   - Input:
       ```
        2 3
        5 3 4
        10 8 9
        4
    
       ```

   - Output:
       ```
        4 5 3 
        8 9 10
     
        1 2 50
        ```
2.  Тест на правильность сортировки, подсчёта произведения максимума и запоминания индексов(это делается по отсортированому массиву)

   - Input:
       ```
        2 3
        4 4 3
        8 4 7
        4
 
       ```

     - Output:
         ```
          4 4 3 
          8 4 7
       
          0 1 0 32
          ```
3. Тест на правильность вывода в транспонированном виде(Выводиться не исходный массив, а отсортированный)
   - Input:
       ```
     2 3
     5 3 4
     10 8 9
     4
       ```

- Output:
    ```
    4 8 
    5 9
    3 10
    ```
4. Тест на правильность вывода в транспонированном виде(Выводиться не исходный массив, а отсортированный)
    - Input:
        ```
      2 3
      4 4 3
      8 4 7
      4
        ```

- Output:
    ```
    4 8 
    4 4
    3 7
    ```
5. Тест на правильность удаления элементов и их подсчёта

- Input:
    ```
    2 3
    5 3 4
    10 8 9
    4
    ```

- Output:
    ```
    5 3 
    9 10
  
    2
    ```
6.Тест на правильность удаления элементов и их подсчёта

- Input:
    ```
    2 3
    4 4 3
    8 4 7
    4
    ```

- Output:
    ```
    3 
    7
  
    4
    ```

