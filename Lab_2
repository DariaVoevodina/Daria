import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        //1. Считываем размеры массива с консоли, его элементы, переменную  k
        //вводим размеры массива n на m
        int n = in.nextInt();
        int m = in.nextInt();
        int[][] a = new int[n][m];
        //вводим элементы массива
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[i].length; j++)
                a[i][j] = in.nextInt();
        //вводим число k
        int k = in.nextInt();

        //2. Сортировка "пузырьком" элементов строк массива по возрастанию остатков от деления элементов на k
        int temp;//создаем локальную переменную, которая понадобиться для запоминания текущего значения элемнта при сортировки
        int temp1;//создаем ещё одну локальную переменную, которая понадобиться для сортировки в случае равенства остатков
        for (int i = 0; i < a.length; i++) { //циклом for идем по строкам двумерного массива
            for (int z = 1; z < m; z++) { //Заводим цикл for для z,необходимый для проверки без предыдущего найденного элемента, дающего наибольший остаток от деления на k
                for (int j = 0; j < m - z; j++) {//Заводим цикл for для j,необходимый для проверки без предыдущего найденного элем ента, дающего наибольший остаток от деления на k
                    if (a[i][j] % k > a[i][j + 1] % k) {//Проверка условия "Если остаток от деления текущего элемента на k больше остатка от деления следующего элемента на k
                        temp = a[i][j];//присваиваем локальной переменной значение текущего элемента массива
                        a[i][j] = a[i][j + 1];//присваваем элементу a[i][j] значение элемента a[i][j+1]
                        a[i][j + 1] = temp;//присваиваем элементу a[i][j+1] значение temp
                    }
                    else {
                        if(a[i][j]%k==a[i][j+1]%k&&a[i][j]<a[i][j+1]){//в случае если остатки от деления элементов на k равны, то сортируем их пузырком по убыванию
                            temp1=a[i][j];//присваиваем локальной переменной значение текущего элемента
                            a[i][j]=a[i][j+1];//присваваем элементу a[i][j] значение элемента a[i][j+1]
                            a[i][j+1]=temp1;//присваиваем элементу a[i][j+1] значение temp
                        }
                    }
                }
            }
        }

        //Это была проверка, на правильность работы программы
        //for (int i = 0; i < a.length; i++) {
            //for (int j = 0; j < a[i].length; j++) {
                //out.print(a[i][j] + " ");
            //}
            //out.println();
        //}

        //3. Находим максимум в каждой строке, произведение максмумов и запоминаем их индексы
        int product=1;//Присваиваем, переменной, в которой будем считать произведение 1 (нейтральный элемент по умножению)
        int max_str;//Инициализируем переменную, которая будет запоминать максимум в каждой строке
        int index_max;//Инициализируем переменную, которая будет запоминать индексы максимумов
        for(int i=0;i<a.length;i++) {//Идем по строкам двумерного массива циклом for
            max_str = Integer.MIN_VALUE;//Для каждой строки обновляем значение максимума, присваиваем ему маленкое значение
            for (int j = 0; j < m; j++) {//Идем по элементам каждой строке массива циклом for
                if (a[i][j] > max_str) {//Сравниваем каждый элемент со значением максимума
                    max_str = a[i][j];//Если он оказался больше текущего максимума, присваиваем максимуму значение элемента
                }
            }
            for (int z=0;z<m;z++){//Снова идем по элементам каждой строки
                index_max=0;
                if (a[i][z]==max_str){//Если элемент, оказался равен максимум, то присваиваем переменной, запоминающей индекс, значение индекса максимума
                    index_max=z;
                    //out.print(z+" ");//Это была проверка на корректность работы программы
                }
            }
            product *= max_str;//Считаем произведение макксимумов
        }
        //out.println(product);//Это была проверка на корректность работы программы

        //4. Создание нового массива (прежний массив в транспонированном виде) и его вывод
        int str=a.length;//Присваиваем переменной str количество строк массива
        int stl=a[0].length;//Присваеваем переменной stl количество столбцов массива
        int [][] transp_a=new int[stl][str];//Создаем новый массив с иными размерами(количество строк - количество столбцов предыдущего массива, количество столбцов - количество строк в предыдущем массиве)
        for (int i=0; i<str;i++){//Идем по строкам предыдущего массива циклом for
            for (int j=0;j<stl;j++){//Идем по элементам каждой строки предыдущего массива
                transp_a[j][i]=a[i][j];//Заполняем новый массив элементами предыдущего
            }
        }
        //Выводим новый получившийся массив на экран(это будет старый массив в транспонированном виде
        for (int i=0;i<stl;i++){
            for (int j=0;j<str;j++){
                out.print(transp_a[i][j]+" ");
            }
            out.println();
        }

        //5. Если элемент делится на k без остатка, то удаляем его из массива
        int count=0;//Обнуляем переменную переменную, которая будетсчитать количество удаленных элементов
        int len=0;//Обнуляем пременную для новой длины строк
        for(int i=0;i<a.length;i++){//Циклом for идем по строкам двумерного массива
            for(int z=0,j=0;j<a[i].length;j++){//Циклом for идем по элементам строки текущий счётчик увеличиваем на 1, также обнуляем счётчик для новой длины строк
                if (a[i][j]%k!=0){//Проверяем условие, если элемент нас устраивает
                    a[i][z]=a[i][j];//То присваиваем элемент
                    z++;//Счётчик новой длины увеличиваем на 1
                }
                else{
                    count++;//Если условие не выполняется, то увеличиваем счётчик для удаленных переменных на 1
                }
                len=z;//Переменной новой длины присваиваем значение z
            }
        }
        //Выводим получившийся массив
        for(int i=0;i<a.length;i++) {
            for (int j = 0; j < len; j++) {
                out.print(a[i][j] + " ");
            }
            out.println();
        }
         out.println(count);//Выводим количество удаленных элементов
    }
}
